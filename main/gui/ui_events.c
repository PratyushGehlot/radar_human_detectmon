/**
 * @file ui_events.c
 * @brief Radar Human Detection & Fall Monitor
 * @details ESP32-S3-BOX-3 based real-time human presence detection and fall
 *          monitoring system using LD6001 mmWave radar sensor.
 * @author PratyushGehlot
 * @see https://github.com/PratyushGehlot/radar_human_detectmon
 */

// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.4
// LVGL version: 8.3.11
// Project name: SquareLine_Project

#include "ui.h"
#include "esp_lvgl_port.h"
#include "esp_log.h"
#include "../app/app_play_wav.h"
#include "bsp/esp-bsp.h"
#include "../app/radar_sensor.h"
#include "../app/wifi_stream.h"
#include <sys/stat.h>
#include <dirent.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_timer.h"

static const char *TAG = "events";

#define AUDIO_COOLDOWN_US  (5 * 1000000LL)

static int64_t s_last_human_audio_time = 0;
static int64_t s_last_fall_audio_time = 0;
static bool    s_prev_human_present = false;
static bool    s_prev_fall_detected = false;
static char    s_alert_audio_path[256];
static volatile bool s_alert_audio_playing = false;
static lv_timer_t *s_fall_iamge_timer = NULL;
static volatile bool s_fall_image_lock = false;

static lv_obj_t * screens[] = {
NULL, // Placeholder for screen 1
NULL, // Placeholder for screen 2
NULL, // Placeholder for screen 3
NULL, // Placeholder for screen 4
};

static uint8_t current_screen_index = 0;
static const uint8_t total_screens = 4;

void ui_navigation_init(void)
{
	//fill the screens array after the screens have been created in ui_init()
	screens[0] = ui_screen1; 
	screens[1] = ui_Screen2;
	screens[2] = ui_Screen3;
	screens[3] = ui_Screen4;

	//add gesture event handler to each screen
	for (int i = 0; i < total_screens; i++) 
	{
		if(screens[i] != NULL) // Skip if the screen is not initialized
		{
			lv_obj_add_flag(screens[i], LV_OBJ_FLAG_EVENT_BUBBLE); // Enable event bubbling for the screen
			lv_obj_add_event_cb(screens[i], ui_screen_gesture_handler, LV_EVENT_GESTURE, NULL);
		}
	}
}

void ui_screen_gesture_handler(lv_event_t * e)
{
	lv_event_code_t code = lv_event_get_code(e);
	lv_dir_t dir = lv_indev_get_gesture_dir(lv_indev_get_act());

	if (code == LV_EVENT_GESTURE) 
	{
		lvgl_port_lock(0); // Lock LVGL to safely update the screen

		if (dir == LV_DIR_LEFT) 
		{
			current_screen_index = (current_screen_index + 1) % total_screens; // Move to next screen

			lv_scr_load_anim(screens[current_screen_index],LV_SCR_LOAD_ANIM_MOVE_LEFT,300,0,false); // Load the new screen
		} 
		else if (dir == LV_DIR_RIGHT) 
		{
			current_screen_index = (current_screen_index - 1 + total_screens) % total_screens; // Move to previous screen

			lv_scr_load_anim(screens[current_screen_index],LV_SCR_LOAD_ANIM_MOVE_RIGHT,300,0,false); // Load the new screen
		}
		
		lvgl_port_unlock(); // Unlock LVGL after updating the screen
	}
}

void slider_height_value_cb(lv_event_t * e)
{
	lv_event_code_t code = lv_event_get_code(e);
	lv_obj_t * slider = lv_event_get_target(e);
	lv_obj_t * label7 = ui_Label7; // Assuming ui_Label7 is globally accessible, otherwise you would need to pass it as user_data in the event callback

	if (code == LV_EVENT_VALUE_CHANGED) 
	{
		int32_t value = lv_slider_get_value(slider);
		ESP_LOGI(TAG, "Slider value changed: %d", value);
		lv_label_set_text_fmt(label7, "%d m", value);
	}
}



void slider_range_value_cb(lv_event_t * e)
{
	lv_event_code_t code = lv_event_get_code(e);
	lv_obj_t * slider = lv_event_get_target(e);
	lv_obj_t * label8 = ui_Label8; // Assuming ui_Label8 is globally accessible, otherwise you would need to pass it as user_data in the event callback

	if (code == LV_EVENT_VALUE_CHANGED) 
	{
		int32_t value = lv_slider_get_value(slider);
		ESP_LOGI(TAG, "Slider range value changed: %d", value);
		lv_label_set_text_fmt(label8, "%d m", value);

	}	
}

void slider_sensitivity_value_cb(lv_event_t * e)
{
	lv_event_code_t code = lv_event_get_code(e);
	lv_obj_t * slider = lv_event_get_target(e);
	lv_obj_t * label9 = ui_Label9; // Assuming ui_Label9 is globally accessible, otherwise you would need to pass it as user_data in the event callback

	if (code == LV_EVENT_VALUE_CHANGED) 
	{
		int32_t value = lv_slider_get_value(slider);
		ESP_LOGI(TAG, "Slider sensitivity value changed: %d", value);
		lv_label_set_text_fmt(label9, "%d", value);
	}
}

void switch_alert_value_cb(lv_event_t * e)
{
	if (ui_Label10 == NULL) return;

	if (lv_obj_has_state(ui_Switch1, LV_STATE_CHECKED)) {
		lv_label_set_text(ui_Label10, "ACTIVE");
	} else {
		lv_label_set_text(ui_Label10, "OFF");
	}
}

void switch_state_value_cb(lv_event_t * e)
{
	if(lv_obj_has_state(ui_Switch2, LV_STATE_CHECKED)) 
	{
		ESP_LOGI(TAG, "radar_start called, Switch is ON");
		lv_label_set_text(ui_Labelstate, "Started");
		radar_start();
	} 
	else 
	{
		ESP_LOGI(TAG, "radar_stop called, Switch is OFF");
		lv_label_set_text(ui_Labelstate, "Stopped");
		radar_stop();
	}
}

void slider_volume_value_cb(lv_event_t * e)
{
	lv_event_code_t code = lv_event_get_code(e);
	lv_obj_t * slider = lv_event_get_target(e);

	if (code == LV_EVENT_VALUE_CHANGED)
	{
		int32_t value = lv_slider_get_value(slider);
		int percent = value * 20;
		ESP_LOGI(TAG, "Volume slider value changed: %d (%d%%)", value, percent);
		lv_label_set_text_fmt(ui_Label45, "%d%%", percent);
		set_speaker_volume(percent);
	}
}

void button_reset_value_cb(lv_event_t * e)
{
	// Your code here
}

static void fall_image_timer_cb(lv_timer_t *timer)
{
	s_fall_image_lock = false; // Unlock the fall image update after the timer expires
	s_fall_iamge_timer = NULL; // Clear the timer handle
	
	//Re-check the current posture to update the fall image if needed
	int count = 0;
	const human_target_t *targets = radar_get_targets(&count);
	bool human_present = (count > 0);
	human_posture_t posture = human_present ? targets[0].posture : POSTURE_NO_PRESENCE;
	bool fall = (posture == POSTURE_FALL);

	ui_screen3_set_fall_detected(human_present, fall);
}	

void ui_screen3_set_fall_detected(bool human_present, bool fall_detected)
{
	if (ui_imgfalldetected == NULL || ui_ImageSafe == NULL) return;

	// if fall image is locked, it means we are in the cooldown period after a fall was detected, so we should not update the image yet
	if (s_fall_image_lock) {
		return;
	}	

	if (fall_detected) {
		lv_obj_clear_flag(ui_imgfalldetected, LV_OBJ_FLAG_HIDDEN);
		lv_obj_add_flag(ui_ImageSafe, LV_OBJ_FLAG_HIDDEN);

		//lock the image for 5 seconds to prevent flickering in case of multiple rapid fall detections
		s_fall_image_lock = true;

		// If there's already a timer running, delete it before creating a new one to reset the cooldown period
		if (s_fall_iamge_timer != NULL) {
			lv_timer_del(s_fall_iamge_timer); // If there's already a timer running, delete it before creating a new one
		}

		// Create a new timer that will unlock the fall image update after 5 seconds
		s_fall_iamge_timer = lv_timer_create(fall_image_timer_cb, 5000, NULL); // Create a timer that will call the callback after 5 seconds		
		lv_timer_set_repeat_count(s_fall_iamge_timer, 1); // Set the timer to run only once


	} else if (human_present) {
		lv_obj_add_flag(ui_imgfalldetected, LV_OBJ_FLAG_HIDDEN);
		lv_obj_clear_flag(ui_ImageSafe, LV_OBJ_FLAG_HIDDEN);
	} else {
		lv_obj_add_flag(ui_imgfalldetected, LV_OBJ_FLAG_HIDDEN);
		lv_obj_add_flag(ui_ImageSafe, LV_OBJ_FLAG_HIDDEN);
	}
}

static void alert_audio_play_task(void *arg)
{
	play_file((void *)s_alert_audio_path);
	ESP_LOGI(TAG, "Alert audio playback completed: %s", s_alert_audio_path);
	s_alert_audio_playing = false;
	vTaskDelete(NULL);
}

static void stop_current_alert_audio(void)
{
	if (s_alert_audio_playing) {
		play_file_request_stop();
		while (s_alert_audio_playing) {
			vTaskDelay(pdMS_TO_TICKS(10));
		}
	}
}

static void play_alert_audio(const char *filename, int64_t *last_time, bool force)
{
	int64_t now = esp_timer_get_time();
	if (!force && (now - *last_time) < AUDIO_COOLDOWN_US) return;

	if (force) {
		stop_current_alert_audio();
	} else if (s_alert_audio_playing) {
		return;
	}

	char full_path[256];
	snprintf(full_path, sizeof(full_path), "%s/%s", BSP_SPIFFS_MOUNT_POINT, filename);

	struct stat st;
	if (stat(full_path, &st) != 0) {
		ESP_LOGE(TAG, "Alert audio not found: %s", full_path);
		return;
	}

	snprintf(s_alert_audio_path, sizeof(s_alert_audio_path), "%s", full_path);
	*last_time = now;
	s_alert_audio_playing = true;
	xTaskCreate(alert_audio_play_task, "alert_audio", 4096, NULL, 5, NULL);
}

static const char *posture_detail_string(const human_target_t *t)
{
	bool moving = (t->avg_velocity > 0.05f || t->avg_velocity < -0.05f);
	switch (t->posture) {
	case POSTURE_STANDING: return moving ? "Standing\nMoving"  : "Standing\nStill";
	case POSTURE_SITTING:  return moving ? "Sitting\nMoving"   : "Sitting\nStill";
	case POSTURE_LYING:    return moving ? "Lying\nMoving"     : "Lying\nStill";
	case POSTURE_SLEEPING: return "Sleeping";
	case POSTURE_FALL:     return "Fall\nDetected";
	default:               return "Unknown";
	}
}

static void screen3_monitor_cb(lv_timer_t *timer)
{
	int count = 0;
	const human_target_t *targets = radar_get_targets(&count);
	bool human_present = (count > 0);
	human_posture_t posture = human_present ? targets[0].posture : POSTURE_NO_PRESENCE;
	bool fall = (posture == POSTURE_FALL);

	bool audio_enabled = (ui_Switch1 != NULL && lv_obj_has_state(ui_Switch1, LV_STATE_CHECKED));

	if (audio_enabled && human_present && !s_prev_human_present) {
		play_alert_audio("humanpresensedetected.wav", &s_last_human_audio_time, false);
	}

	if (audio_enabled && fall && !s_prev_fall_detected) {
		play_alert_audio("attention.wav", &s_last_fall_audio_time, true);
	}

	s_prev_human_present = human_present;
	s_prev_fall_detected = fall;

	if (ui_Label32 != NULL) {
		lv_label_set_text(ui_Label32, human_present ? "Human Detected" : "No one");
	}

	if (ui_Label34 != NULL) {
		lv_label_set_text(ui_Label34, human_present ? posture_detail_string(&targets[0]) : "---");
	}

	ui_screen3_set_fall_detected(human_present, fall);
	ui_screen3_set_posture(posture);
	ui_screen4_update_sensor_log();
	ui_screen4_update_client_ip();
}

void ui_screen3_start_monitor(void)
{
	lv_timer_create(screen3_monitor_cb, 500, NULL);
}

static void hide_all_posture_images(void)
{
	lv_obj_add_flag(ui_imgsitting, LV_OBJ_FLAG_HIDDEN);
	lv_obj_add_flag(ui_imgdownsit, LV_OBJ_FLAG_HIDDEN);
	lv_obj_add_flag(ui_imgstanding, LV_OBJ_FLAG_HIDDEN);
	lv_obj_add_flag(ui_imglying, LV_OBJ_FLAG_HIDDEN);
	lv_obj_add_flag(ui_imgfall, LV_OBJ_FLAG_HIDDEN);
}

void ui_screen3_set_posture(human_posture_t posture)
{
	if (ui_imgsitting == NULL) return;

	hide_all_posture_images();

	switch (posture) {
	case POSTURE_SITTING:
		lv_obj_clear_flag(ui_imgsitting, LV_OBJ_FLAG_HIDDEN);
		break;
	case POSTURE_SLEEPING:
		lv_obj_clear_flag(ui_imgdownsit, LV_OBJ_FLAG_HIDDEN);
		break;
	case POSTURE_STANDING:
		lv_obj_clear_flag(ui_imgstanding, LV_OBJ_FLAG_HIDDEN);
		break;
	case POSTURE_LYING:
		lv_obj_clear_flag(ui_imglying, LV_OBJ_FLAG_HIDDEN);
		break;
	case POSTURE_FALL:
		lv_obj_clear_flag(ui_imgfall, LV_OBJ_FLAG_HIDDEN);
		break;
	case POSTURE_NO_PRESENCE:
	default:
		break;
	}
}

void ui_screen4_update_sensor_log(void)
{
	if (ui_TextArea9 == NULL) return;

	int count = 0;
	const human_target_t *targets = radar_get_targets(&count);
	if (count == 0) {
		lv_textarea_set_text(ui_TextArea9, "No targets detected");
		return;
	}

	char buf[512] = {0};
	int offset = 0;
	for (int i = 0; i < count && offset < (int)sizeof(buf) - 1; i++) {
		offset += snprintf(buf + offset, sizeof(buf) - offset,
			"T[%d]: %s (%.2f,%.2f,%.2f) v=%.2f c=%.2f p=%d\n",
			i, radar_posture_to_string(targets[i].posture),
			targets[i].center_x, targets[i].center_y, targets[i].center_z,
			targets[i].avg_velocity, targets[i].confidence, targets[i].point_count);
	}
	lv_textarea_set_text(ui_TextArea9, buf);
}

void ui_screen4_update_client_ip(void)
{
	if (ui_Label25 == NULL) return;

	const char *ip = wifi_stream_get_client_ip();
	if (ip != NULL) {
		lv_label_set_text(ui_Label25, ip);
	} else {
		lv_label_set_text(ui_Label25, "No client connected");
	}
}

/*Task to play audio and animate progress bar*/
static char boot_audio_path[256];

static void bar_anim_cb(void * var, int32_t value)
{
	lv_bar_set_value((lv_obj_t *)var, value, LV_ANIM_OFF);
}

static void boot_audio_play_task(void * arg)
{
	play_file((void *)boot_audio_path);
	ESP_LOGI(TAG, "Boot audio playback completed.");
	vTaskDelete(NULL);
}

static void bar_anim_ready_cb(lv_anim_t * a)
{
	ESP_LOGI(TAG, "Bar animation completed, starting audio playback");
	xTaskCreate(boot_audio_play_task, "boot_audio", 4096, NULL, 5, NULL);
}

/* after boot load screen1 with bar loading animation and play boot_audio.wav file (duration 3 seconds)*/
void load_progressbar_and_playaudio(void)
{
	char full_path[256];
	snprintf(full_path, sizeof(full_path), "%s/%s", BSP_SPIFFS_MOUNT_POINT, "bootaudio.wav");

	/*Verify file exists*/
	struct stat st;
	if (stat(full_path, &st) != 0) {
		ESP_LOGE(TAG, "Audio file not found: %s", full_path);
		ESP_LOGE(TAG, "Aviable files in SPIFFS:");

		DIR *dir = opendir(BSP_SPIFFS_MOUNT_POINT);
		if (dir) {
			struct dirent *entry;
			while ((entry = readdir(dir)) != NULL) {
				ESP_LOGI(TAG, " - %s", entry->d_name);
			}
			closedir(dir);
		}
		return;
	}

	ESP_LOGI(TAG, "Audio file found: %s, size: %d bytes", full_path, (int)st.st_size);

	snprintf(boot_audio_path, sizeof(boot_audio_path), "%s", full_path);

	/* Lock LVGL */
	lvgl_port_lock(0);

	/* Load screen1 */
	lv_scr_load(ui_screen1);

	/* Animate bar from 0 to 100 over 2 seconds, play audio when done */
	lv_bar_set_value(ui_Bar1, 0, LV_ANIM_OFF);

	lv_anim_t a;
	lv_anim_init(&a);
	lv_anim_set_var(&a, ui_Bar1);
	lv_anim_set_values(&a, 0, 100);
	lv_anim_set_time(&a, 1500);
	lv_anim_set_exec_cb(&a, bar_anim_cb);
	lv_anim_set_ready_cb(&a, bar_anim_ready_cb);
	lv_anim_start(&a);

	/* Unlock LVGL */
	lvgl_port_unlock();
}